[
  {
    "objectID": "posts/wine_production/wine_production.html",
    "href": "posts/wine_production/wine_production.html",
    "title": "Veni, vidi, bibi",
    "section": "",
    "text": "Wine is one of the most widely enjoyed alcoholic beverages in the world. It carries a rich cultural heritage and a fascinating history that dates back thousands of years. Recent studies have shown that grapes were actually domesticated twice almost concurrently in western Asia and the Caucasus almost 11000 years ago(Dong et al. 2023). Early farmers that migrated from western Asia towards the Iberian peninisula brough with them the domesticated grapevines. These vines were in turn cross-bred with local varieties which created muscat grapes which were high in sugar. These were the earliest progenitors of the different grape varieties that are found today in many European wine-making regions. Grapes for wine making continued to be cultivated througout Europe and then spread across the globe. Today wine-making is a large industry, worth billions of euros in exports per year.\nBut it is notably dependent on the climate. Knowing how it will grow under expected, familiar conditions gives it the consistency necessary for industry. How and where has wine been made - and which kinds of wine - across Europe? How much can we expect in trade per year? And what will happen in future years, with the threat of climate change?\nIn this series of blogposts, we will look at many different aspects of wine production in Europe using the latest public datasets. In particular, we will follow the following roadmap (click to get more details):\n\n\n\n\n\n\nPart I: Vineyards and wine production\n\n\n\n\n\nIn this part, we will explore where in Europe wine production takes place, as well as the volume of wine produced by different countries. We will also look into historical trends in wine production.\n\n\n\n\n\n\n\n\n\nPart II: Wine export and consumption\n\n\n\n\n\nIn this part, we will look into the details of wine trade as well as trends in wine consumption.\n\n\n\n\n\n\n\n\n\nPart III: Climate and wine\n\n\n\n\n\nIn this part, we will take a deep dive into what climactic factors affect wine and will examine their effects on historical data.\n\n\n\n\n\n\n\n\n\nPart IV: Climate change and the future\n\n\n\n\n\nWe will conclude by taking a look what different state-of-the-art climate models predict for the coming decades and what implications this has for wine making."
  },
  {
    "objectID": "posts/wine_production/wine_production.html#introduction",
    "href": "posts/wine_production/wine_production.html#introduction",
    "title": "Veni, vidi, bibi",
    "section": "",
    "text": "Wine is one of the most widely enjoyed alcoholic beverages in the world. It carries a rich cultural heritage and a fascinating history that dates back thousands of years. Recent studies have shown that grapes were actually domesticated twice almost concurrently in western Asia and the Caucasus almost 11000 years ago(Dong et al. 2023). Early farmers that migrated from western Asia towards the Iberian peninisula brough with them the domesticated grapevines. These vines were in turn cross-bred with local varieties which created muscat grapes which were high in sugar. These were the earliest progenitors of the different grape varieties that are found today in many European wine-making regions. Grapes for wine making continued to be cultivated througout Europe and then spread across the globe. Today wine-making is a large industry, worth billions of euros in exports per year.\nBut it is notably dependent on the climate. Knowing how it will grow under expected, familiar conditions gives it the consistency necessary for industry. How and where has wine been made - and which kinds of wine - across Europe? How much can we expect in trade per year? And what will happen in future years, with the threat of climate change?\nIn this series of blogposts, we will look at many different aspects of wine production in Europe using the latest public datasets. In particular, we will follow the following roadmap (click to get more details):\n\n\n\n\n\n\nPart I: Vineyards and wine production\n\n\n\n\n\nIn this part, we will explore where in Europe wine production takes place, as well as the volume of wine produced by different countries. We will also look into historical trends in wine production.\n\n\n\n\n\n\n\n\n\nPart II: Wine export and consumption\n\n\n\n\n\nIn this part, we will look into the details of wine trade as well as trends in wine consumption.\n\n\n\n\n\n\n\n\n\nPart III: Climate and wine\n\n\n\n\n\nIn this part, we will take a deep dive into what climactic factors affect wine and will examine their effects on historical data.\n\n\n\n\n\n\n\n\n\nPart IV: Climate change and the future\n\n\n\n\n\nWe will conclude by taking a look what different state-of-the-art climate models predict for the coming decades and what implications this has for wine making."
  },
  {
    "objectID": "posts/wine_production/wine_production.html#setting-up-the-analysis-environment",
    "href": "posts/wine_production/wine_production.html#setting-up-the-analysis-environment",
    "title": "Veni, vidi, bibi",
    "section": "1.2 Setting up the analysis environment",
    "text": "1.2 Setting up the analysis environment\nTo perform this analysis, we will use Python and many of the standard data science packages written for it. In particular we will rely heavily on pandas and matplotlib. If you have not encountered these before it is highly recommended to get familiar with them first.\nIn order to ensure a reproducible analysis, we encourage people to use an isolated Python environment (a virtual environment). While there are many different ways of doing this, we recommend using conda/mamba since it also allows for convenient management of C dependencies. A detailed description of how to set up the environment can be found in Section 2.1.\nLet’s load all the packages we need and set up some defaults (the matplotlib style file and additional analysis functions are here):\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport matplotlib\nimport rasterio\nimport cartopy.crs as ccrs\nimport cartopy.feature as cf\nimport cartopy\nimport rioxarray\nfrom rich import print as pprint\nDATADIR = \"../../../wine_analysis/data/\"\n# Use out custom matplotlib style\nplt.style.use(\"../../analysis/setup/wine_analysis.mplstyle\")\n# Use some matplotlib helpers\nimport sys\nsys.path.append(\"../../analysis/scripts/\")\nfrom matplotlib_extensions import *"
  },
  {
    "objectID": "posts/wine_production/wine_production.html#wine-production-in-europe",
    "href": "posts/wine_production/wine_production.html#wine-production-in-europe",
    "title": "Veni, vidi, bibi",
    "section": "1.3 Wine production in Europe",
    "text": "1.3 Wine production in Europe\n\n1.3.1 Where is it?\nThe EU is the largest producer and exporter of wine in the world. Making and consuming wine is a long-held tradition in many European countries. Traditionally, this production has been mostly limited to southern parts of the EU where the conditions are optimal for growing different types of wine. Wine needs warm weather, lots of sun, and a fair amount of rain.\nOur first goal is to map the modern location of European vineyards. To do this, we will of course need an extensive dataset of vineyard locations. While it’s possible to attempt to build such a dataset from scratch - starting for example from registration data for wineries in the EU - satellite land usage maps already provide a very complete data set. These surveys divide the surface of the Earth into a grid and classify the satellite data within each cell into different classes based on what the land is used for.\nThe Corine Land Cover (CLC) inventory is the largest database of land cover and land use available for Europe. The first release was 1990 and since then it has been updated several times: 2000, 2006, 2012, and the latest release in 2018. What makes the CLC particularly useful for us is that it explicitly separates vineyards from other types of agricultural use. CLC data is and available freely for research use. We’ll use the CLC 2018 dataset to create a map of wine production in Europe.\nThe data is available in three different formats: raster (GEOTiff), SQLite or ESRI database. For simplicity we use the GEOTiff raster format, which represents the data as values on a regularly-spaced grid. It comes with extensive documentation, including how to load and examine the data using the QGIS open-source application. See Section 2.2.1 for details on obtaining the data.\nBefore diving into the details, it is worth taking a quick look at the data inside the file. This can be done with gdalinfo, a command-line utility that comes as part of the GDAL library (it was installed as one of the dependencies in the mamba environment above). Executing the following:\ngdalinfo ${DATADIR}/wine_statistics/u2018_clc2018_v2020_20u1_raster100m/DATA/u2018_clc2018_v2020_20u1_raster100m.tif | nl\nyields (we suppress some output for clarity but the line numbers correspond to what one would see)\n1   Driver: GTiff/GeoTIFF\n2   Files: ../../../data/wine_statistics/u2018_clc2018_v2020_20u1_raster100m/DATA/U2018_CLC2018_V2020_20u1.tif\n3         ../../../data/wine_statistics/u2018_clc2018_v2020_20u1_raster100m/DATA/U2018_CLC2018_V2020_20u1.tif.ovr\n4         ../../../data/wine_statistics/u2018_clc2018_v2020_20u1_raster100m/DATA/U2018_CLC2018_V2020_20u1.tif.aux.xml\n15   Size is 65000, 46000\n26   Coordinate System is:\n7   PROJCRS[\"ETRS89-extended / LAEA Europe\",\n8      BASEGEOGCRS[\"ETRS89\",\n9          DATUM[\"European Terrestrial Reference System 1989\",\n10             ELLIPSOID[\"GRS 1980\",6378137,298.257222101004,\n11                 LENGTHUNIT[\"metre\",1]]],\n12         PRIMEM[\"Greenwich\",0,\n13             ANGLEUNIT[\"degree\",0.0174532925199433]],\n14         ID[\"EPSG\",4258]],\n15     CONVERSION[\"Lambert Azimuthal Equal Area\",\n16         METHOD[\"Lambert Azimuthal Equal Area\",\n17             ID[\"EPSG\",9820]],\n18         PARAMETER[\"Latitude of natural origin\",52,\n19             ANGLEUNIT[\"degree\",0.0174532925199433],\n20             ID[\"EPSG\",8801]],\n21         PARAMETER[\"Longitude of natural origin\",10,\n22             ANGLEUNIT[\"degree\",0.0174532925199433],\n23             ID[\"EPSG\",8802]],\n24         PARAMETER[\"False easting\",4321000,\n25             LENGTHUNIT[\"metre\",1],\n26             ID[\"EPSG\",8806]],\n27         PARAMETER[\"False northing\",3210000,\n28             LENGTHUNIT[\"metre\",1],\n29             ID[\"EPSG\",8807]]],\n30     CS[Cartesian,2],\n31         AXIS[\"(E)\",east,\n32             ORDER[1],\n33             LENGTHUNIT[\"metre\",1]],\n34         AXIS[\"(N)\",north,\n35             ORDER[2],\n36             LENGTHUNIT[\"metre\",1]],\n37     ID[\"EPSG\",3035]]\n[--------------------------------SNIP-----------------------------------------------------]\n47  Corner Coordinates:\n48  Upper Left  (  900000.000, 5500000.000) ( 56d30'18.51\"W, 56d29' 4.75\"N)\n[--------------------------------SNIP-----------------------------------------------------]\n353  Band 1 Block=128x128 Type=Int8, ColorInterp=Gray\n54   Min=1.000 Max=48.000\n55   Minimum=1.000, Maximum=48.000, Mean=25.753, StdDev=11.680\n456   NoData Value=-128\n[--------------------------------SNIP-----------------------------------------------------]\n\n1\n\nLine 5 : the data is on a \\(65000\\times46000\\) grid, corresponding to a spatial resolution of 100 meters.\n\n2\n\nLines 6-35: detailed description of the coordinate system used to represent the spatial data, given in Well-known text (WKT) format. See this post for more information on coordinate systems frequently used in GIS.\n\n3\n\nLines 53-54: the land use classes are encoded as integers of type Int8 with values ranging from 1 to 48. We will need to figure out what number corresponds to vineyards.\n\n4\n\nLine 56: missing values are indicated by -128.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nOne should be careful when loading this data into any tool that treats all numerical values as float64 types, because while a \\(65000\\times46000\\) array of Int8 occupies ~3 GB, the same array of float64 type would occupy 8 times more: ~24 GB.\n\n\n\nxarray package provides a great way of interacting with this sort of data via xarray.DataArray which is a multi-dimensional labelled datatype. One can think of it either as a generalization of a multi-dimensional numpy array where more data about the dimensions is stored. There is also a package rioxarray which can load raster file types like GEOTiff directly into xarray objects:\n\n# Get the data\ndset = rioxarray.open_rasterio(\n    f\"{DATADIR}/wine_statistics/u2018_clc2018_v2020_20u1_raster100m/DATA/U2018_CLC2018_V2020_20u1.tif\"\n)\ndset\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (band: 1, y: 46000, x: 65000)&gt;\n[2990000000 values with dtype=int8]\nCoordinates:\n  * band         (band) int64 1\n  * x            (x) float64 9e+05 9.002e+05 9.002e+05 ... 7.4e+06 7.4e+06\n  * y            (y) float64 5.5e+06 5.5e+06 5.5e+06 ... 9.002e+05 9e+05\n    spatial_ref  int64 0\nAttributes: (12/13)\n    AREA_OR_POINT:           Area\n    DataType:                Thematic\n    RepresentationType:      THEMATIC\n    STATISTICS_COVARIANCES:  136.429646247598\n    STATISTICS_MAXIMUM:      48\n    STATISTICS_MEAN:         25.753373398066\n    ...                      ...\n    STATISTICS_SKIPFACTORX:  1\n    STATISTICS_SKIPFACTORY:  1\n    STATISTICS_STDDEV:       11.680310194836\n    _FillValue:              -128\n    scale_factor:            1.0\n    add_offset:              0.0xarray.DataArrayband: 1y: 46000x: 65000...[2990000000 values with dtype=int8]Coordinates: (4)band(band)int641array([1])x(x)float649e+05 9.002e+05 ... 7.4e+06 7.4e+06array([ 900050.,  900150.,  900250., ..., 7399750., 7399850., 7399950.])y(y)float645.5e+06 5.5e+06 ... 9.002e+05 9e+05array([5499950., 5499850., 5499750., ...,  900250.,  900150.,  900050.])spatial_ref()int640crs_wkt :PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314140356inverse_flattening :298.257222101004reference_ellipsoid_name :GRS 1980longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :ETRS89horizontal_datum_name :European Terrestrial Reference System 1989projected_crs_name :ETRS89-extended / LAEA Europegrid_mapping_name :lambert_azimuthal_equal_arealatitude_of_projection_origin :52.0longitude_of_projection_origin :10.0false_easting :4321000.0false_northing :3210000.0spatial_ref :PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]GeoTransform :900000.0 100.0 0.0 5500000.0 0.0 -100.0array(0)Indexes: (3)bandPandasIndexPandasIndex(Index([1], dtype='int64', name='band'))xPandasIndexPandasIndex(Index([ 900050.0,  900150.0,  900250.0,  900350.0,  900450.0,  900550.0,\n        900650.0,  900750.0,  900850.0,  900950.0,\n       ...\n       7399050.0, 7399150.0, 7399250.0, 7399350.0, 7399450.0, 7399550.0,\n       7399650.0, 7399750.0, 7399850.0, 7399950.0],\n      dtype='float64', name='x', length=65000))yPandasIndexPandasIndex(Index([5499950.0, 5499850.0, 5499750.0, 5499650.0, 5499550.0, 5499450.0,\n       5499350.0, 5499250.0, 5499150.0, 5499050.0,\n       ...\n        900950.0,  900850.0,  900750.0,  900650.0,  900550.0,  900450.0,\n        900350.0,  900250.0,  900150.0,  900050.0],\n      dtype='float64', name='y', length=46000))Attributes: (13)AREA_OR_POINT :AreaDataType :ThematicRepresentationType :THEMATICSTATISTICS_COVARIANCES :136.429646247598STATISTICS_MAXIMUM :48STATISTICS_MEAN :25.753373398066STATISTICS_MINIMUM :1STATISTICS_SKIPFACTORX :1STATISTICS_SKIPFACTORY :1STATISTICS_STDDEV :11.680310194836_FillValue :-128scale_factor :1.0add_offset :0.0\n\n\nLooking at the dataset, we see that the x and y coordinates represent the centers of the cells (you can easily tell this from: i) the shape of the data is the same as coordinates ii) the first x coordinate is actually 50 meters offset from the corner value we saw above ). Let’s convert the actual values to a 2D numpy array:\n\nar = dset.sel(band=1).to_numpy()\n\nLet’s verify that the data values are indeed what we expect:\n\npprint(np.unique(ar))\n\n[-128    1    2    3    4    5    6    7    8    9   10   11   12   13\n   14   15   16   17   18   19   20   21   22   23   24   25   26   27\n   28   29   30   31   32   33   34   35   36   37   38   39   40   41\n   42   43   44   48]\n\n\n\nNow according to the official docs the designation class for vineyards is 221 so we need to find what value between 1 and 48 this corresponds to. A simple way is to just search for “221”, for example with grep -R \"221\" $DATADIR/wine_statistics/u2018_clc2018_v2020_20u1_raster100m/* immediately yields as one of the results:\nclc_legend_qgis_raster.qml:        &lt;paletteEntry color=\"#e68000\" label=\"221 - Vineyards\" value=\"15\" alpha=\"255\"/&gt;\nand thus the value we need is 15. Thus let’s find the indices of the cells which correspond to this value and then get the actual x-y coords\n\nindices = np.where(ar == 15)\nx = dset.x[indices[1]].to_numpy()\ny = dset.y[indices[0]].to_numpy()\n\nNow, in order to make the map, we need to use the correct projection. We can easily obtain this information as follows:\n\ngeo_attrs = dset.spatial_ref.attrs\npprint(pd.Series(geo_attrs))\n\ncrs_wkt                           PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[...\nsemi_major_axis                                                           6378137.0\nsemi_minor_axis                                                       6356752.31414\ninverse_flattening                                                       298.257222\nreference_ellipsoid_name                                                   GRS 1980\nlongitude_of_prime_meridian                                                     0.0\nprime_meridian_name                                                       Greenwich\ngeographic_crs_name                                                          ETRS89\nhorizontal_datum_name                    European Terrestrial Reference System 1989\nprojected_crs_name                                    ETRS89-extended / LAEA Europe\ngrid_mapping_name                                      lambert_azimuthal_equal_area\nlatitude_of_projection_origin                                                  52.0\nlongitude_of_projection_origin                                                 10.0\nfalse_easting                                                             4321000.0\nfalse_northing                                                            3210000.0\nspatial_ref                       PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[...\nGeoTransform                                900000.0 100.0 0.0 5500000.0 0.0 -100.0\ndtype: object\n\n\n\nThe next step is to create the cartopy transformation object so that we can convert the map of the countries from their default projection to the same projection as our raster dataset.\n\n# Create a globe object with the same ellipsoid\nglobe = cartopy.crs.Globe(ellipse=\"GRS80\")\n# Create the correct projection\nmy_ccr = ccrs.LambertAzimuthalEqualArea(\n    central_longitude=geo_attrs[\"longitude_of_projection_origin\"],\n    central_latitude=geo_attrs[\"latitude_of_projection_origin\"],\n    false_easting=geo_attrs[\"false_easting\"],\n    false_northing=geo_attrs[\"false_northing\"],\n    globe=globe,\n)\n\nFinally, we make the plot:\n\n\nShow the code\nplt.figure(figsize=(12, 8))\n\nax = plt.axes(projection=my_ccr)\n\n# Resolution to use\nresol = \"50m\"\n# Country borders\nbodr = cartopy.feature.NaturalEarthFeature(\n    category=\"cultural\",\n    edgecolor=\"gray\",\n    lw=0.5,\n    name=\"admin_0_boundary_lines_land\",\n    scale=resol,\n    facecolor=\"none\",\n)\n# Land, i.e. coastlines\nland = cartopy.feature.NaturalEarthFeature(\n    \"physical\", \"land\", scale=resol, edgecolor=\"gray\", lw=0.5, facecolor=\"#fad5b1\"\n)\n# Ocean\nocean = cartopy.feature.NaturalEarthFeature(\n    \"physical\", \"ocean\", scale=resol, edgecolor=\"none\", facecolor=\"#f0f8ff\"\n)\nax.add_feature(land, facecolor=\"#fad5b1\", zorder=1)\n# Note that ocean is broken for this projection so it fills the entire globe\n# Thus we just make it a background\nax.add_feature(ocean, linewidth=0.2, zorder=-1)\nax.add_feature(bodr, zorder=2)\n\nax.scatter(x, y, marker=\"o\", color=\"r\", alpha=0.01, s=0.1)\ngl = ax.gridlines(\n    draw_labels=True, linewidth=1, color=\"gray\", alpha=0.5, linestyle=\":\", zorder=0\n)\n# Limits set by eye\nax.set_xlim(2400000, 7400000)\nax.set_ylim(1500000, 3500000)\n# Create empty ticks so we can label the axes\nax.set_xticks([])\nax.set_yticks([])\nax.set_xlabel(\"Longitude\", labelpad=15, fontsize=18)\nax.set_ylabel(\"Latitude\", labelpad=35, fontsize=18)\nplt.title(\"Wine-making regions of Europe\", fontsize=30, fontweight=\"light\", pad=20)\nplt.tight_layout()\n\n\n\n\n\nThis looks very similar to Fig.2 in (Droulia and Charalampopoulos 2022), although they appear to have used a different (and unspecified) projection. We see that indeed the majority of the vineyards are situated in southern Europe, and virtually none exist above the latitude of \\(50 ^{\\circ}N\\). As we expect: grapes for wine like hot, sunny weather.\nLet’s now look more quantitatively at which countries have the largest amount of vineyards. To do so, we use the data from Eurostat. This is a great resource for all statistical data within the EU.\nFor this purpose, we will use Eurostat’s VIT_T1 dataset that lists the land usage by different wine types for every EU member state, as well as the EF_LUS_MAIN dataset that gives a more general overview of all agricultural/farm land area use. For instructions on how to obtain this data, see Section 2.2.2.\nThe detailed code that loads the data, selects the appropriate subsets of both datasets, and merges it into something which is easier to plot is found here.\nArmed with the right data, we can finally visualize the land usage statistics. We will use the matplotlib package along with squarify to create two different ways of looking at the data.\n\n\nShow the code\nimport squarify\nimport seaborn as sns\n\naxis_fontsize = 16\nlbl_fontsize = 20\nfig = plt.figure(figsize=(13, 6))\n\n# Left: donut plot\nax = plt.subplot(121)\nax = labelled_pie(\n    df_to_plot[\"value\"].values,\n    df_to_plot[\"COUNTRY NAME\"].values,\n    \"Area under vine in the EU for 2020\",\n    ax=ax,\n)\nax.text(\n    -0.25,\n    -0.15,\n    f\"Total area\\n{np.round(total_area/1e6,1)} mha\",\n    fontweight=\"light\",\n    fontsize=18,\n)\n\n\nplt.title(\"Fraction of total vineyard area\", pad=30, fontweight=\"light\", fontsize=22)\n\n# Right: square area plot\nplt.subplot(122)\nax2 = squarify.plot(\n    sizes=df_to_plot[\"value\"],\n    color=plt.rcParams[\"axes.prop_cycle\"].by_key()[\"color\"],\n    label=labels,\n    text_kwargs={\"fontsize\": 16, \"color\": \"white\", \"fontweight\": \"normal\"},\n    edgecolor=\"white\",\n)\nax2.tick_params(axis=\"both\", labelsize=axis_fontsize)\nax2.xaxis.label.set_size(lbl_fontsize)\nax2.yaxis.label.set_size(lbl_fontsize)\nax2.xaxis.label.set_fontweight(\"light\")\nax2.yaxis.label.set_fontweight(\"light\")\n\nax2.spines[[\"left\", \"bottom\"]].set_visible(False)\nax2.xaxis.set_visible(False)\nax2.yaxis.set_visible(False)\nplt.subplots_adjust(wspace=0.5)\nplt.title(\n    \"Area (fraction of all permanent crops)\", pad=20, fontweight=\"light\", fontsize=22\n)\n_ = plt.suptitle(\n    f\"Area under vine in the EU for 2020\", fontsize=30, fontweight=\"light\", y=1.08\n)\n\n\n\n\n\nWe can clearly see that:\n\nSpain, France and Italy have the largest vineyards, together comprising almost 3/4 of all vineyard area in the EU,\nFor all the top 5 countries, vineyards occupy a sizable fraction of all permanent crop lands, ranging from 20% for Spain to 77% for France.\n\n\n\n1.3.2 Production volume\nNext, let’s take a look at the volume of wine produced within the EU. After all, just because there is a vineyard doesn’t mean it successfully produced wine.\nFor this, we use a custom dataset which can be obtained from the “Wine Production and opening stocks” dashboard of the Directorate-General of Agriculture and Rural Development. See Section 2.2.3 for details on getting this data.\n\ndf_production = pd.read_excel(f\"{DATADIR}/wine_statistics/production_data_dgard.xlsx\")\ndf_production.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2573 entries, 0 to 2572\nData columns (total 10 columns):\n #   Column         Non-Null Count  Dtype  \n---  ------         --------------  -----  \n 0   Member State   2573 non-null   object \n 1   MS Code        2573 non-null   object \n 2   Category       2573 non-null   object \n 3   Product Group  2573 non-null   object \n 4   Year           2573 non-null   int64  \n 5   Production     2573 non-null   float64\n 6   Opening Stock  2573 non-null   float64\n 7   Availability   2573 non-null   float64\n 8   Area           2573 non-null   float64\n 9   Yield          2573 non-null   object \ndtypes: float64(4), int64(1), object(5)\nmemory usage: 201.1+ KB\n\n\nThe relevant columns to use are:\n\nMember State - country reporting\nCategory and Product Group - type of product being produced\nYear - year reported\nProduction- the volume of wine produced in thousands of hectorliters (1 hl = 100 l).\n\nTaking a peek at the type of products being produced, we see:\n\nnp.unique(df_production[['Category','Product Group']])\n\narray(['-', 'Non-GI', 'Non-Vinified', 'Other wines', 'P.D.O. wines',\n       'P.G.I. wines', 'Table wine', 'VQPRD wines', 'Varietal'],\n      dtype=object)\n\n\nThe most salient difference is thus “Non-Vinified” products (i.e., not wine) vs everything else (i.e., wine).\nLet’s narrow things down to only wines, group by country and year, and sum the production over everything else (i.e., Category and Product Group):\n\n# Group all wines by country and year\ndf_tmp = df_production[\n    (df_production[\"Category\"] != \"Non-Vinified\")\n    & (df_production[\"Product Group\"] != \"Non-Vinified\")\n].groupby([\"Member State\", \"Year\"])\ndf_tmp.head()\n# Now sum over all the wine types. \nres = df_tmp[\"Production\"].sum().reset_index() # reset_index turns this from a Series back into a DataFrame\nres.head()\n\n\n\n\n\n\n\n\nMember State\nYear\nProduction\n\n\n\n\n0\nAustria\n1999\n2803.000\n\n\n1\nAustria\n2000\n2335.000\n\n\n2\nAustria\n2001\n2492.600\n\n\n3\nAustria\n2002\n2566.300\n\n\n4\nAustria\n2003\n2519.615\n\n\n\n\n\n\n\nLet’s focus on 2022 and see which countries have the largest shares of the overall production.\n\nyear = 2022\ndf_year = res[res[\"Year\"] == year]\n# For plotting we will group together all countries which produce less than 5%\n# of the total\ntotal = df_year[\"Production\"].sum()\nth = 0.05 * total\n\ndf_to_plot = df_year[df_year[\"Production\"] &gt;= th]\nrow = pd.DataFrame(\n    {\n        \"Member State\": \"Others\",\n        \"Year\": year,\n        \"Production\": df_year[df_year[\"Production\"] &lt; th][\"Production\"].sum(),\n    },\n    index=[0],\n)\ndf_to_plot = pd.concat([df_to_plot, row], ignore_index=True)\n# Sort in descending order by volume  produced\ndf_to_plot = df_to_plot.sort_values(\"Production\", ascending=False)\n# Total production in mega- hectorliters (so 10^8 liters)\ntotal_volume = df_to_plot[\"Production\"].sum()/1000\n\ndf_to_plot.head()\n\n\n\n\n\n\n\n\nMember State\nYear\nProduction\n\n\n\n\n2\nItaly\n2022\n49842.611\n\n\n0\nFrance\n2022\n44355.621\n\n\n3\nSpain\n2022\n35780.936\n\n\n4\nOthers\n2022\n20423.086\n\n\n1\nGermany\n2022\n8551.084\n\n\n\n\n\n\n\nThis data gives the following plot:\n\n\nShow the code\nfig, ax = plt.subplots(figsize=(10, 6), subplot_kw=dict(aspect=\"equal\"))\nax = labelled_pie(\n    df_to_plot[\"Production\"].values,\n    df_to_plot[\"Member State\"].values,\n    f\"EU wine production by volume in {year}\",\n    ax=ax,\n)\n_ = plt.text(\n    -0.35,\n    -0.15,\n    f\"Total volume\\n{int(np.round(total_volume,0))} mhl\",\n    fontweight=\"light\",\n    fontsize=16,\n)\n\n\n\n\n\nUnsurprisingly we see that the three countries that domainated by area of vineyards also dominate the production: Italy, France and Spain.\nTo put the total volume produced into context, it is\n\nabout 60% of the total world wine production(oiv2022?)\napproximately 33 L of wine for every person in the EU1\nenough to fill about 6900 Olympic swimming pools2\n\nLet’s now look at the historical trends, focusing on the top three wine producers. In order to make our findings more robust, we also include data from two additional sources:\n\nThe database of the International Organisation of Vine and Wine (OIV). See Section 2.2.4 for more details.\nThe database (Anderson and A. J. Holmes 2021) from Wine Economics Reasearch Institute at University of Adelaide. This database is a single Excel file with over 100 sheets and contains a wealth of historical information. See Section 2.2.5 for more details.\n\n\n\nShow the code\n# Extract the top 3 producers\ndominant_producers = df_to_plot[\"Member State\"].values[:3]\n\n# Load the data from the Wine Economics Research Institute\ndf_WERI = pd.ExcelFile(\n    f\"{DATADIR}/wine_statistics/Megafile_of_global_wine_data_1835_to_2016_1217.xlsx\"\n)\n# Select the right sheet\ndf_production_WERI = df_WERI.parse(\"T6 Wine production\", header=1)\n# Rename the no-name column with year\ndf_production_WERI = df_production_WERI.rename(columns={\"Unnamed: 0\": \"Year\"})\ndf_tcmp = df_production_WERI[df_production_WERI[\"Year\"].isin(res[\"Year\"].values)]\n# Load data from the OIV\ndf_oiv = pd.read_excel(f\"{DATADIR}/wine_statistics/oiv_data.xlsx\")\n# We need to select the appropriate units of volume. Note the strange /xa0 character which shows\n# up as a space!\ndf_production_OIV = df_oiv[(df_oiv[\"Variable\"] == \"Production\") & (df_oiv['Unit'] == \"1000\\xa0hl\")]\n\n\n# Setup some defaults\ngolden = (1 + np.sqrt(5)) / 2\nwidth = 10\nheight = width / golden\nax = setup_timeseries_plot(width=width, height=height)\n\n# Note the changes in the quantities being plotted: everything is converted to\n# mega hectorliters (mha, 1e8 litres)\nfor country in dominant_producers:\n    tmp = res[res[\"Member State\"] == country]\n    (line,) = ax.plot(tmp[\"Year\"], tmp[\"Production\"] / 1000, label=country)\n    tmp_oiv = df_production_OIV[df_production_OIV[\"Region/Country\"] == country]\n    ax.plot(tmp_oiv[\"Year\"], tmp_oiv[\"Quantity\"] / 1e3, ls=\":\", color=line.get_color())\n    ax.plot(\n        df_tcmp[\"Year\"], df_tcmp[country] * 10 / 1e6, ls=\"--\", color=line.get_color()\n    )\n    \n\n# Manually create the legend to distinguish the datasets\nfrom matplotlib.lines import Line2D\nline1 = Line2D([0], [0], label='Eurostat', color='k')\nline2 = Line2D([0], [0], label='OIV', color='k',ls=\":\")\nline3 = Line2D([0], [0], label='WERI', color='k',ls=\"--\")\nhandles, labels = ax.get_legend_handles_labels()\nhandles.extend([line1,line2,line3])\nax.legend(handles=handles,ncol=2,loc=4, prop={\"size\": 14, \"weight\": \"light\"})\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Volume (millions of hectolitres)\")\n_ = ax.set_title(\"Top wine producers in the EU\", fontsize=30, fontweight=\"light\")\n\n\n\n\n\nInterestingly the three data sources agree very well for France and Spain but disagree substantially for Italy. If one takes the Eurostat dataset and add back the “Non-Vinified” data, one gets the following:\n\n\nShow the code\n# Data where _all_ grape production is included\nres2 = df_production.groupby([\"Member State\", \"Year\"])[\"Production\"].sum().reset_index()\n\nax = setup_timeseries_plot(width=width, height=height)\n\n# Note the changes in the quantities being plotted: everything is converted to\n# mega hectorliters (mha, 1e8 litres)\ncountry = \"Italy\"\ntmp = res[res[\"Member State\"] == country]\ntmp2 = res2[res2[\"Member State\"] == country]\n\n(line,) = ax.plot(tmp[\"Year\"], tmp[\"Production\"] / 1000, label=\"Eurostat\")\nax.plot(tmp2[\"Year\"], tmp2[\"Production\"] / 1000, label=\"Eurostat, all\", ls=\"-\")\ntmp_oiv = df_production_OIV[df_production_OIV[\"Region/Country\"] == country]\nax.plot(tmp_oiv[\"Year\"], tmp_oiv[\"Quantity\"] / 1e3, ls=\"--\", label=\"OIV\")\nax.plot(df_tcmp[\"Year\"], df_tcmp[country] * 10 / 1e6, ls=\":\", label=\"WERI\")\n\nax.legend(loc=3, prop={\"size\": 14, \"weight\": \"light\"})\n\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Volume (millions of hectolitres)\")\n_ = ax.set_title(\"Italy wine production\", fontsize=30, fontweight=\"light\")\n\n\n\n\n\nThus it appears that there is some sort of inconsistency in the reporting of the production volume, which affects Italy in particular.\nThe WERI data set actually extends much further into the past for some countries, so it’s interesting to see even more long-term trends:\n\n\nShow the code\nax = setup_timeseries_plot(width=width,height=height)\nfor country in dominant_producers:\n    ax.plot(\n        df_production_WERI[\"Year\"], df_production_WERI[country] * 10 / 1e6, ls=\"-\",label=country\n    )\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Volume (millions of hectolitres)\")\n_ = ax.legend(loc=2, prop={\"size\": 14, \"weight\": \"light\"})\n\n\n\n\n\nA few interesting things to observe:\n\nHistorically, Italy and France produced far more wine than Spain\nThe production of wine reached the highest recorded value around 1975 for Italy and France and has been declining ever since, with current levels at about 50% of the peak."
  },
  {
    "objectID": "posts/wine_production/wine_production.html#sec-env",
    "href": "posts/wine_production/wine_production.html#sec-env",
    "title": "Veni, vidi, bibi",
    "section": "2.1 Analysis environment",
    "text": "2.1 Analysis environment\nFor the Python setup we use mambaforge as a drop-in replacement for the more widely known conda. You can download the latest version from the website or run:\nwget https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-Linux-x86_64.sh\nand then execute the file.\nThe yaml file with all the dependencies can be found here. To install everything, run the following command (if you prefer to use conda, you will need to first do conda config --add channels conda-forge and then replace mamba with conda everywhere below):\nmamba env create -f environment.yml\nThen activate the environment with\nmamba activate wine-analysis"
  },
  {
    "objectID": "posts/wine_production/wine_production.html#datasets",
    "href": "posts/wine_production/wine_production.html#datasets",
    "title": "Veni, vidi, bibi",
    "section": "2.2 Datasets",
    "text": "2.2 Datasets\nThe appendix describes in detail how to obtain the datasets used in this blog.\n\n2.2.1 Corine Land Cover\nThe Corine Land Cover dataset provides multi-year, land coverage data for Europe, with the latest release being CLC-2018. To obtain the data:\n\nGo to the latest data release. Click “Download” in the left side-bar.\nRegister for the EU Login if you don’t have one /Log in if you already do\nScroll down to “Download pre-packaged data collections” and select “u2018_clc2018_v2020_20u1_raster100m”\nClick “Add to cart”\nGo to your cart, select this dataset and click “Start downloading”. This will queue your task.\nNavigate to “Downloads process page”. There you will see your task go from “Queued” first to “In progress” and then finally to “Completed” at which point you can click the “Download file” link to actually download your data.\nUnzip the data and it’s ready for use\n\n\n\n2.2.2 Eurostat data\nBy far the easiest way to get the relevant data is through the web interface. Alternatively one could either:\n\nDownload directly with e.g. curl -o wine_land_usage_area_vit_t1.csv.gz https://ec.europa.eu/eurostat/estat-navtree-portlet-prod/BulkDownloadListing?file=data/vit_t1.tsv.gz\nUse the REST API, see e.g. here for more information. Note that the parsing of the resulting data can be a bit involved.\nUse a language-specific third-party package for Eurostat data, for example for Python or for R\nUse a package for parsing SDMX data, for example pandasdmx.\n\nWe use approach d. in order to ensure easy reproducibility and allow us to retrieve any number of datasets from Eurostat. The 2 datasets we use in this analysis are\n\nVIT_T1 for detailed overview of vineyard area in the EU\nEF_LUS_MAIN for overall land use by the agriculture sector in the EU\n\nAs an example let’s get the data from VIT_T1. Conveniently, the pandasdmx package already has a client for retriving data from Eurostat. For example:\n\nimport pandasdmx as sdmx\nestat = sdmx.Request(\"ESTAT\")\nresp = estat.data(\"VIT_T1\",key={'unit':'HA'}) # Only take land area in units of hectares\ndf = sdmx.to_pandas(resp).reset_index() # reset_index() makes it a flat dataframe\ndf.head()\n\n\n\n\n\n\n\n\nfreq\nvinetype\nunit\ngeo\nTIME_PERIOD\nvalue\n\n\n\n\n0\nA\nIN\nHA\nAT\n2015\n43489.0\n\n\n1\nA\nIN\nHA\nAT\n2020\n44501.0\n\n\n2\nA\nIN\nHA\nAT11\n2015\n11799.0\n\n\n3\nA\nIN\nHA\nAT11\n2020\n11642.0\n\n\n4\nA\nIN\nHA\nAT12\n2015\n26885.0\n\n\n\n\n\n\n\nThe script to retrieve all the datasets (and associated metadata) and dump it to convenient json files is here.\n\n\n2.2.3 Wine production data from Directorate-General for Agriculture and Rural Development\nThe DGARD maintains a dashboard that pulls together various statistics on wine production in the EU. To get the data:\n\nNavigate to the dashboard\nClick the “triangle” at the top right corner and select “Data explorer”\nClick the “Export data” icon on the right of the header row. This will download the Excel file with the data.\n\n\n\n2.2.4 OIV statistics database\nThe International Organization of Vine and Wine (OIV) maintains a database of statistical data about many aspects of wine making. One can download the data used in this analysis as follows:\n\nGo to the database section of the OIV website\nSelect “Europe” from the “Continent” drop-down\nClick on the “…” at the upper right corner of the table (“More options”) and select “Export data”\nLeave the selection on “Data with current layout” and click “Export”\n\n\n\n2.2.5 WERI wine database\nThe Wine Economics Reasearch Institute at University of Adelaide maintains an extensive database of historical data related to wine. To obtain this data:\n\nGo to the database website\nClick “Download megafile of global wine data”"
  },
  {
    "objectID": "posts/wine_production/wine_production.html#footnotes",
    "href": "posts/wine_production/wine_production.html#footnotes",
    "title": "Veni, vidi, bibi",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee the demographics data here↩︎\nAssuming as standard swimming-pool capacity of \\(2.5\\times 10^{6}\\) liters.↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The elephant of surprise",
    "section": "",
    "text": "Hello!\nI’m Serguei, a data engineer, data scientist and software developer with a background in gravitational wave astrophysics.\nI build pipelines that use data, statistics and machine learning to solve complex problems.\n\n\n\n\n\nVisualization of the binary neutron star merger event GW170817 created by me and my colleagues from full numerical simulations. See more visualizations here.\n\n\n\n\n\n\nI recently transitioned from academia, where I specialized in modelling signals from compact object binaries (mostly black holes, but sometimes neutron stars and even more exotic things). For 7 years I was part of the LIGO collaboration, working on understanding gravitational wave events with scientists around the globe. Now, I apply the same skills to many diverse problems in data science.\n\n\n\n\nBlog - Thoughts and insights on data science, machine learning and the associated software.\nPortfolio - Various data science, machine learning and data engineering projects.\nCV - A detailed look at my academic and professional journey.\nResources - Tools and resources I found useful\n\n\n\n\nI’m always open to discussing new opportunities, collaborations, or just chatting about data science (or astrophysics, or statistics, or board games). Feel free to reach out!\n\nEmail: serguei.ossokine at tutanota.com\nLinkedIn: Serguei Ossokine\nGitHub: SergeiOssokine"
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "The elephant of surprise",
    "section": "",
    "text": "Hello!\nI’m Serguei, a data engineer, data scientist and software developer with a background in gravitational wave astrophysics.\nI build pipelines that use data, statistics and machine learning to solve complex problems.\n\n\n\n\n\nVisualization of the binary neutron star merger event GW170817 created by me and my colleagues from full numerical simulations. See more visualizations here.\n\n\n\n\n\n\nI recently transitioned from academia, where I specialized in modelling signals from compact object binaries (mostly black holes, but sometimes neutron stars and even more exotic things). For 7 years I was part of the LIGO collaboration, working on understanding gravitational wave events with scientists around the globe. Now, I apply the same skills to many diverse problems in data science.\n\n\n\n\nBlog - Thoughts and insights on data science, machine learning and the associated software.\nPortfolio - Various data science, machine learning and data engineering projects.\nCV - A detailed look at my academic and professional journey.\nResources - Tools and resources I found useful\n\n\n\n\nI’m always open to discussing new opportunities, collaborations, or just chatting about data science (or astrophysics, or statistics, or board games). Feel free to reach out!\n\nEmail: serguei.ossokine at tutanota.com\nLinkedIn: Serguei Ossokine\nGitHub: SergeiOssokine"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "About Me",
    "section": "",
    "text": "Download CV as pdf"
  },
  {
    "objectID": "cv.html#cv",
    "href": "cv.html#cv",
    "title": "About Me",
    "section": "",
    "text": "Download CV as pdf"
  },
  {
    "objectID": "cv.html#certifications",
    "href": "cv.html#certifications",
    "title": "About Me",
    "section": "Certifications",
    "text": "Certifications"
  },
  {
    "objectID": "cv.html#audited-courses",
    "href": "cv.html#audited-courses",
    "title": "About Me",
    "section": "Audited courses",
    "text": "Audited courses\n\nStatistical Learning with Python: a comprehensive course on statistical modelling ranging from classical ML techniques like Logistic Regression and Support Vector Machines to more modern techinqiues like Gradient Boosting Machines and Deep Learning."
  },
  {
    "objectID": "cv.html#publications",
    "href": "cv.html#publications",
    "title": "About Me",
    "section": "Publications",
    "text": "Publications\n\nShort-author papers\n\nvan de Meent et al., “Enhancing the SEOBNRv5 effective-one-body waveform model with second-order gravitational self-force fluxes”. DOI:10.1103/PhysRevD.108.124038\n\nKhalil et al., “Theoretical groundwork supporting the precessing-spin two-body dynamics of the effective-one-body waveform models SEOBNRv5”. DOI:10.1103/PhysRevD.108.124036\n\nPompili et al., “Laying the foundation of the effective-one-body waveform models SEOBNRv5: Improved accuracy and efficiency for spinning nonprecessing binary black holes”. DOI:10.1103/PhysRevD.108.124035\n\nRamos-Buades et al., “Next generation of accurate and efficient multipolar precessing-spin effective-one-body waveforms for binary black holes”. DOI:10.1103/PhysRevD.108.124037\n\nMihaylov et al., “pySEOBNR: a software package for the next generation of effective-one-body multipolar waveform models”. arXiv:2303.18203\n\nToubiana et al., “Detectability and parameter estimation of GWTC-3 events with LISA”. DOI:10.1103/PhysRevD.106.104034\n\nGadre et al., “Fully precessing higher-mode surrogate model of effective-one-body waveforms”. DOI:10.1103/PhysRevD.110.124038\n\nRamos-Buades et al., “Effective-one-body multipolar waveforms for eccentric binary black holes with nonprecessing spins”. DOI:10.1103/PhysRevD.105.044035\n\nMihaylov et al., “Fast post-adiabatic waveforms in the time domain: Applications to compact binary coalescences in LIGO and Virgo”. DOI:10.1103/PhysRevD.104.124087\n\nEstellés et al., “A Detailed Analysis of GW190521 with Phenomenological Waveform Models”. DOI:10.3847/1538-4357/ac33a0\n\nOssokine et al., “Multipolar Effective-One-Body Waveforms for Precessing Binary Black Holes: Construction and Validation”. DOI:10.1103/PhysRevD.102.044055\n\nHinder et al., “Gravitational waveforms for high spin and high mass-ratio binary black holes: A synergistic use of numerical-relativity codes”. DOI:10.1103/PhysRevD.99.061501\n\nDietrich, Tim, Ossokine, Serguei, and Clough, Katy, “Full 3D numerical relativity simulations of neutron star–boson star collisions with BAM”. DOI:10.1088/1361-6382/aaf43e\n\nCotesta et al., “Enriching the Symphony of Gravitational Waves from Binary Black Holes by Tuning Higher Harmonics”. DOI:10.1103/PhysRevD.98.084028\n\nOssokine et al., “Assessing the Energetics of Spinning Binary Black Hole Systems”. DOI:10.1103/PhysRevD.98.104057\n\nSennett et al., “Distinguishing Boson Stars from Black Holes and Neutron Stars from Tidal Interactions in Inspiraling Binary Systems”. DOI:10.1103/PhysRevD.96.024002\n\nBohé et al., “Improved effective-one-body model of spinning, nonprecessing binary black holes for the era of gravitational-wave astrophysics with advanced detectors”. DOI:10.1103/PhysRevD.95.044028\n\nTacik et al., “Binary Neutron Stars with Arbitrary Spins in Numerical Relativity”. DOI:10.1103/PhysRevD.92.124012\n\nOssokine et al., “Improvements to the construction of binary black hole initial data”. DOI:10.1088/0264-9381/32/24/245010\n\nOssokine et al., “Comparing Post-Newtonian and Numerical-Relativity Precession Dynamics”. DOI:10.1103/PhysRevD.92.104028\n\nBoyle et al., “Gravitational-wave modes from precessing black-hole binaries”. arXiv:1409.4431\n\nMroue et al., “Catalog of 174 Binary Black Hole Simulations for Gravitational Wave Astronomy”. DOI:10.1103/PhysRevLett.111.241104\n\nOssokine, Serguei, Kidder, Lawrence E., and Pfeiffer, Harald P., “Precession-tracking coordinates for simulations of compact-object-binaries”. DOI:10.1103/PhysRevD.88.084031\n\nYou can find all papers where I am an author here."
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "My Projects",
    "section": "",
    "text": "Air quality capstone\n\n\nAn end-to-end data engineering project to analyse air quality data for Berlin\n\n\n\nSerguei Ossokine\n\n\n\n\n\n\n\n\n\n\n\n\n\nIaC Rosetta Stone for streaming models in AWS\n\n\nThis project shows how to deploy a simple ML model to AWS in a variety of ways, providing a ‘Rosetta stone’.\n\n\n\nSerguei Ossokine\n\n\n\n\n\n\n\n\n\n\n\n\n\nDroughtwatch capstone\n\n\nAn end-to-end pipeline to build, deploy and monitor a CNN model predicting forage quality of land from satallite data\n\n\n\nSerguei Ossokine\n\n\n\n\n\n\n\n\n\n\n\n\n\nWine production analysis\n\n\nAn in-depth analysis of wine production in Europe\n\n\n\nSerguei Ossokine\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/airquality.html",
    "href": "projects/airquality.html",
    "title": "Air quality capstone",
    "section": "",
    "text": "In this project, I construct an end-to-end data pipeline to download, clean, enrich and transform air quality data for Berlin. The pipeline is orchestrated using Prefect Cloud, leveraging GCP infrastructure provisioned via Terraform. The data is transformed via dbt and findings are presented in a dashboard hosted on Preset cloud. You can find the code here and extensive documentation here."
  }
]